#include <iostream>
using namespace std;
#pragma once
enum Color{ RED, BLACK };
template <class V>
struct RBTreeNode
{
	RBTreeNode(const V& val = V(), Color color = RED)
	:_pLeft(nullptr)
	, _pRight(nullptr)
	, _pParent(nullptr)
	, _val(val)
	, _color(color)
	{}
	RBTreeNode<V>* _pLeft;
	RBTreeNode<V>* _pRight;
	RBTreeNode<V>* _pParent;
	V _val;
	Color _color;
};
template <class V>
class RBTree
{
	typedef RBTreeNode<V> Node;
public:
	RBTree()
		:_pHead(new Node)
	{
		//将头结点创建好
		_pHead->_pParent = nullptr;
		_pHead->_pLeft = _pHead;
		_pHead->_pRight = _pHead;
	}
	bool Insert(const V& data)//插入
	{
		Node*& pRoot = GetRoot();//获得根结点
		if (nullptr == pRoot)
		{
			pRoot = new Node(data, BLACK);//根结点是黑色的
			pRoot->_pParent = _pHead;
		}
		else
		{
			//按照二叉搜索树的性质插入新的结点
			//1、找待插入结点在二叉搜索树中的位置
			Node* pCur = pRoot;
			Node* pParent = _pHead;
			while (pCur)
			{
				pParent = pCur;
				if (data < pCur->_val)
				{
					pCur = pCur->_pLeft;
				}
				else if (data>pCur->_val)
				{
					pCur = pCur->_pRight;
				}
				else
					return false;
			}
			//插入新结点
			pCur = new Node(data);
			if (data < pParent->_val)
			{
				pParent->_pLeft = pCur;
			}
			else
			{
				pParent->_pRight = pCur;
			}
			pCur->_pParent = pParent;//更新插入结点的双亲


			//如果pParent是红色的，插入的新结点默认颜色也是红色的，违反了红黑树的性质
			while (pParent != _pHead &&pParent->_color == RED)//要考虑双亲到达根结点的情况，如果是这样，就不需要调整了，因此加上第一个条件
			{
				//分情况讨论
				Node* GrandFather = pParent->_pParent;//先找到祖父结点，这个祖父节点不需要判空，因为双亲节点是红色，而根据红黑树的性质，根结点一定是黑色，因此双亲一定有双亲
				if (pParent == GrandFather->_pLeft)//双亲是祖父的左孩子（左半边）
				{
					Node* uncle = GrandFather->_pRight;
					//情况1：叔叔结点存在且为红色
					if (uncle&&uncle->_color == RED)
					{
						pParent->_color = BLACK;
						uncle->_color = BLACK;
						GrandFather->_color = RED;
						pCur = GrandFather;
						pParent = pCur->_pParent;
					}
					else//剩下情况2和情况3
					{
						//先处理情况3（pCur是双亲的右孩子，叔叔结点可能不存在||存在且为黑色）
						if (pCur = pParent->_pRight)
						{//情况3与情况2的区别在于将情况3以双亲为根结点的子树进行左单旋，然后交换双亲和pCur的位置交换就得到了情况1
							RotateL(pParent);
							swap(pParent, pCur);
						}
						//情况2
						GrandFather->_color = RED;
						pParent->_color = BLACK;
						RotateR(GrandFather);//右单旋完成之后就不需要再继续向上更新了，因为上面是红色或者黑色已经不重要了
					}
				}
				else//双亲是祖父的右孩子（右半边）
				{
					Node* uncle = GrandFather->_pLeft;//定义叔叔结点
					//情况1
					if (uncle && uncle->_color == RED)
					{
						pParent->_color = BLACK;
						uncle->_color = BLACK;
						GrandFather->_color = RED;
						pCur = GrandFather;
						pParent = pCur->_pParent;
					}
					else//剩下情况2和情况3
					{
						//先处理情况3,转换为情况2
						if (pCur == pParent->_pLeft)
						{
							RotateR(pParent);
							swap(pCur, pParent);
						}
						//情况2
						GrandFather->_color = RED;
						pParent->_color = BLACK;
						RotateL(GrandFather);
					}
				}
			}

		}
		_pHead->_pLeft = LeftMost();//头结点的_pLeft域指向最小的结点
		_pHead->_pRight = RightMost();//头结点的_pRight域指向最大的节点
		pRoot->_color = BLACK;//将根结点的颜色设置为黑色，因为有可能根节点颜色会改变
		return true;
	}
	//红黑树的验证
	void Inorder()//中序遍历
	{
		return _Inorder(GetRoot());
	}
	bool IsValidRBTree()//验证红黑树的性质
	{
		Node* pRoot = GetRoot();
		if (nullptr == pRoot)
			return true;
		//判断根结点是否是黑色
		if (BLACK != pRoot->_color)
		{
			cout << "违反红黑树性质2：根结点不是黑色" << endl;
			return false;
		}
		//性质4和性质3
		//获取一条路径中黑色结点的个数
		Node* pCur = pRoot;
		size_t BlackCount = 0;
		while (pCur)
		{
			if (pCur->_color == BLACK)
				++BlackCount;
			pCur = pCur->_pLeft;
		}
		size_t pathCount = 0;
		return _IsValidRBTree(GetRoot(), BlackCount, pathCount);//封装性质3、4
	}
	Node* LeftMost()//获取红黑树的最左边的结点
	{
		Node* pCur = GetRoot();//从根结点开始找
		if (nullptr == pCur)
			return _pHead;
		while (pCur->_pLeft)//找最左侧结点
			pCur = pCur->_pLeft;
		return pCur;
	}
	Node* RightMost()//获取红黑树最右边的结点
	{
		Node* pCur = GetRoot();
		if (pCur == nullptr)
			return _pHead;
		while (pCur->_pRight)
			pCur = pCur->_pRight;
		return pCur;
	}

private:
	Node*& GetRoot()//获取根结点
	{
		return _pHead->_pParent;
	}
	bool _IsValidRBTree(Node* pRoot, size_t BlackCount, size_t pathCount)//遍历一条路径上的黑色结点,pathCount代表当前路径有几个黑色结点
		//这里pathCount前面不能加引用，因为如果加了引用，这个统计的就不是一条路径上黑色结点的个数，而是整个红黑树黑色结点的个数，因为如果函数体中对这个pathCount形参修改了，他一条路径上的结果就会带出去，遗留数据
	{
		if (nullptr == pRoot)
		{
			return true;
		}
		if (BLACK == pRoot->_color)
		{
			pathCount++;
		}
		Node* pParent = pRoot->_pParent;
		if (pParent != _pHead&&pParent->_color == RED&&pRoot->_color == RED)
		{
			cout << "违反性质3：不能存在连在一起的红色结点" << endl;
			return false;
		}
		if (nullptr == pRoot->_pLeft && nullptr == pRoot->_pRight)//到达叶子结点
		{
			if (pathCount != BlackCount)
			{
				cout << "不符合性质4：每条路径黑色节点的个数不相同" << endl;
				return false;
			}

		}
		return _IsValidRBTree(pRoot->_pLeft, BlackCount, pathCount) && _IsValidRBTree(pRoot->_pRight, BlackCount, pathCount);
	}
	void RotateL(Node* pParent)//左单旋
	{
		Node* pSubR = pParent->_pRight;
		Node* pSubRL = pSubR->_pLeft;

		pParent->_pRight = pSubRL;
		if (pSubRL)
			pSubRL->_pParent = pParent;

		pSubR->_pLeft = pParent;
		Node* pPParent = pParent->_pParent;
		pSubR->_pParent = pPParent;
		pParent->_pParent = pSubR;

		if (pPParent == _pHead)
			_pHead->_pParent = pSubR;
		else
		{
			if (pParent == pPParent->_pLeft)
				pPParent->_pLeft = pSubR;
			else
				pPParent->_pRight = pSubR;
		}
		//红黑树没有必要更新平衡因子
	}
	void RotateR(Node* pParent)//右单旋
	{
		Node* pSubL = pParent->_pLeft;
		Node* pSubLR = pSubL->_pRight;

		pParent->_pLeft = pSubLR;
		if (pSubLR)
			pSubLR->_pParent = pParent;

		pSubL->_pRight = pParent;

		Node* pPParent = pParent->_pParent;
		pParent->_pParent = pSubL;
		pSubL->_pParent = pPParent;

		if (pPParent == _pHead)
			_pHead->_pParent = pSubL;
		else
		{
			if (pParent == pPParent->_pLeft)
				pPParent->_pLeft = pSubL;
			else
				pPParent->_pRight = pSubL;
		}
	}
	void _Inorder(Node* pRoot)
	{
		if (pRoot)
		{
			_Inorder(pRoot->_pLeft);
			cout << pRoot->_val << " ";
			_Inorder(pRoot->_pRight);
		}
	}

private:
	Node* _pHead;//记录头结点即可
};
void TestRBTree()//验证红黑树
{
	int arr[] = { 5, 3, 4, 1, 7, 8, 2, 6, 0, 9 };
	RBTree<int> t;
	for (auto e : arr)
		t.Insert(e);
	t.Inorder();
	cout << endl;
	cout << t.LeftMost()->_val << endl;
	cout << t.RightMost()->_val << endl;
	if (t.IsValidRBTree())
		cout << ":)" << endl;
	else
		cout << ":(" << endl;
}
int main()
{
	TestRBTree();
	return 0;
}